#!/usr/bin/env python3
"""
Generates plots / figures of the parameter and the observable posteriors
of bayesian analysis for comparisons with experimental data or closure tests.

In the code, each plot is generated by a function tagged with the ``@plot``
decorator, which saves the figure.
"""

import copy
import itertools
import logging
import warnings
from collections import OrderedDict
from pathlib import Path

import dill
#import hsluv
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
#import plotly.graph_objects as go
import seaborn as sns
from matplotlib import lines, patches, ticker
#from plotly.subplots import make_subplots
#from SALib.analyze import sobol
#from SALib.sample import saltelli
from scipy import optimize, stats
from scipy.interpolate import PchipInterpolator

#from bayes_exp import Y_exp_data
from bayes_mcmc import *
from calculations_load import MAP_data, trimmed_model_data
#from compare_events import model_data_1, model_data_2
from configurations import *
from bins_and_cuts import *
#from design import Design
#from emulator import Trained_Emulators
#from mcmc_diagnostics import autocorrelation
#from priors import *
from emulator import *
#from bayes_exp import Y_exp_data
from calculations_load import trimmed_model_data, validation_data
import random

logging.getLogger().setLevel(logging.INFO)
print("Plotting parameter samples drawn from posterior")

# Set the MCMC chain to be read
if run_closure:
    chain_string = "chain-idf-0" + "-closure-val-pt_" + str(closure_val_pt) + ".hdf"
    chain = Chain(path=workdir / "mcmc" / chain_string)
else:
    chain = Chain(path=workdir / "mcmc" / "chain-idf-0.hdf")

# Read parameter data into numpy array and then convert into pandas dataframe
data = chain.load_wo_reshape()
data = data.reshape(-1, 20)
dataframe = pd.DataFrame.from_records(data)


# read in validation model calculations
dsv = {}
dsv['Au-Au-200'] = np.fromfile("./model_calculations/production_375pts_Au_Au_200/Obs/validation.dat", dtype=bayes_dtype) #, dtype=bayes_dtype
dsv['d-Au-200'] = np.fromfile("./model_calculations/production_375pts_d_Au_200/Obs/validation.dat", dtype=bayes_dtype) #, dtype=bayes_dtype

plotdir = workdir / "posteriors" / ""
plotdir.mkdir(exist_ok=True)


# Load the emulators
emu_dict = {}
for s in system_strs:
    # load the dill'ed emulator from emulator file
    print(
        "Loading emulators from emulator/emulator-"
        + s
        + "-idf-"
        + str(idf)
        + ".dill"
    )
    emu_dict[s] = dill.load(
        open("emulator/emulator-" + s + "-idf-" + str(idf) + ".dill", "rb")
    )
    #emu = dill.load(
        #open("emulator/emulator-" + s + "-idf-" + str(idf) + ".dill", "rb")
    #)
    print("NPC = " + str(emu_dict[s].npc))


design, design_max, design_min, labels = load_design(s, pset="validation")
#print("Validation design set shape : (Npoints, Nparams) =  ", design.shape)


# Latex labels dictionary
param_dict = {
       'ylossParam4At2' : '$y_{loss}$ at 2',
       'ylossParam4At4' : '$y_{loss}$ at 4',
       'ylossParam4At6' : '$y_{loss}$ at 6',
       'ylossParam4var': '$y_{loss}$ Var',
       'remnant_energy_loss_fraction' : 'Remnant E loss Frac.',
       'shadowing_factor' : 'Shadowing Factor',
       'tau_form_mean' : r'$\tau_{form}$ Mean',
       'BG' : 'BG',
       'string_source_sigma_x' : 'String Source $\sigma_x$',
       'string_source_sigma_eta': 'String Source $\sigma_\eta$',
       'stringTransverseShiftFrac' : 'String Trans. Shift Frac.',
       'shear_viscosity_3_eta_over_s_T_kink_in_GeV': r'$\frac{\eta}{s}$ $T_{kink}$',
       'shear_viscosity_3_eta_over_s_low_T_slope_in_GeV' : r'$\frac{\eta}{s}$ low-T slope',
       'shear_viscosity_3_eta_over_s_high_T_slope_in_GeV' : r'$\frac{\eta}{s}$ high-T slope',
       'shear_viscosity_3_eta_over_s_at_kink' : r'$\frac{\eta}{s}$ at kink',
       'bulk_viscosity_3_zeta_over_s_max' : r'$\frac{\zeta}{s}$ max',
       'bulk_viscosity_3_zeta_over_s_T_peak_in_GeV' : r'$\frac{\zeta}{s}$ $T_{peak}$',
       'bulk_viscosity_3_zeta_over_s_width_in_GeV' : r'$\frac{\zeta}{s}$ width',
       'bulk_viscosity_3_zeta_over_s_lambda_asymm' : r'$\frac{\zeta}{s}$ $\lambda$ assym.',
       'eps_switch' : 'EPS Switch'}


# Define grid-wise functions to calculate parameters across a range
def y_loss(y_init, ylossparam4at2, ylossparam4at4, ylossparam4at6):
    y_loss = 0;
    y_loss1 = ylossparam4at2
    y_loss2 = ylossparam4at4
    y_loss3 = ylossparam4at6

    if (y_init <= 2):
        y_loss = y_loss1/2.*y_init
    elif (y_init <= 4):# & (y_init > 2):
        y_loss = (y_loss2 - y_loss1)/2.*y_init +(2.*y_loss1 - y_loss2); #y_loss1
    elif (y_init <= 6):# & (y_init > 4):
        y_loss = (y_loss3 - y_loss2)/2.*y_init + (3.*y_loss2 - 2.*y_loss3); #y_loss2
    return(y_loss)
y_loss = np.vectorize(y_loss)

def zeta_over_s(T, zmax, T0, width, asym):
    DeltaT = T - T0
    sign = 1 if DeltaT>0 else -1
    x = DeltaT/(width*(1.+asym*sign))
    return zmax/(1.+x**2)
zeta_over_s = np.vectorize(zeta_over_s)

def eta_over_s(T, T_k, alow, ahigh, etas_k):
    if T < T_k:
        y = etas_k + alow*(T-T_k)
    else:
        y = etas_k + ahigh*(T-T_k)
    if y > 0:
        return y
    else:
        return 0.
eta_over_s = np.vectorize(eta_over_s)




def plot(f):
    """
        Decorator for plot function. Calls the function and saves the figure produced.
        More functionalities to be added.
    """

    def wrapper():
        logging.info("Generating posterior plots!")

        if run_closure:
            file_ending = '_closure-val-pt_' + str(closure_val_pt)
        else:
            file_ending = ''

        if "corner" in f.__name__:
            print("Calling function: {}".format(f.__name__))
            fig, spec_plotdir, chain_length, fraction_of_samples = f()
                # save figures
            fig.savefig(str(spec_plotdir) + "/{}_".format(f.__name__) + str(int(chain_length)) + file_ending, dpi=150)

        elif ("trio" in f.__name__) or ("obs" in f.__name__):
            print("Calling function: {}".format(f.__name__))
            figs, spec_plotdir, names, chain_length = f()
                # save figures
            for i, figure in enumerate(figs):
                figure.savefig(str(spec_plotdir) + "/{}_".format(f.__name__) + names[i] + "_" + str(int(chain_length)) + file_ending, dpi=150)

    return wrapper



@plot
def plot_posterior_corner_20_params():

    # modify this path to store the posterior plot produced by this function in a given directory
    spec_plotdir = workdir / "posteriors" / ""
    spec_plotdir.mkdir(exist_ok=True)

    # Select parameters to plot
    parameters_to_plot = range(20) #[0,1,2,15,16,20]
    sns.color_palette("flare")

    # take representative sample of full posterior
    chain_length = len(dataframe); fraction_of_samples = 0.02
    n_samples = int(fraction_of_samples*chain_length)
    sample = random.sample(range(0,chain_length), n_samples)
    print("Sampling " + str(int(n_samples)) + " (" + str(100*fraction_of_samples) + "%) parameter sets of posterior chain of length " + str(chain_length))

    # plot the posteriors
    g = sns.PairGrid(dataframe.iloc[sample,parameters_to_plot], corner=True, diag_sharey=False)
    g.map_lower(sns.kdeplot, color=sns.color_palette()[9], fill=False)
    g.map_upper(sns.kdeplot, color=sns.color_palette()[6], fill=False)
    g.map_diag(sns.kdeplot, linewidth=.5, fill=True, color=sns.color_palette()[3])

    # mark specific parameters (like truth for closure test, or MAP for experimental data analysis)
    if run_closure:
        truth_params = design.iloc[closure_val_pt].values

        # plot the truth parameters
        for i,n in enumerate(parameters_to_plot):
            ax=g.axes[i][i]
            ax.axvline(x=truth_params[n], ls='--', c=sns.color_palette()[5], label='Truth')

    # set axes labels
    label_list = list(param_dict.keys())
    for i, param in enumerate(parameters_to_plot):
        label = label_list[param] #label = label_list[int(ax.xaxis.get_label_text())]
        # label x-axes
        g.axes[len(parameters_to_plot)-1,i].xaxis.set_label_text(param_dict[label], fontsize = 14, visible=True)
        # label y-axes
        g.axes[i,0].yaxis.set_label_text(param_dict[label], fontsize = 14, visible=True)

    # add legend
    #g = g.add_legend(loc='upper right', fontsize=36)
    plt.tight_layout()

    print("\nMaking corner plot of the posterior probability distributions of: \n")
    print(label_list[parameters_to_plot])
    return g, spec_plotdir, chain_length, fraction_of_samples


@plot
def plot_posterior_corner_rap_loss_bulk():

    # modify this path to store the posterior plot produced by this function in a given directory
    spec_plotdir = workdir / "posteriors" / ""
    spec_plotdir.mkdir(exist_ok=True)

    # Select parameters to plot
    parameters_to_plot = [0,1,2,15,16]
    sns.color_palette("Set2")

    # take representative sample of full posterior
    chain_length = len(dataframe); fraction_of_samples = 0.02
    n_samples = int(fraction_of_samples*chain_length)
    sample = random.sample(range(0,chain_length), n_samples)
    print("Sampling " + str(int(n_samples)) + " (" + str(100*fraction_of_samples) + "%) parameter sets of posterior chain of length " + str(chain_length))

    # plot the posteriors
    g = sns.PairGrid(dataframe.iloc[sample,parameters_to_plot], corner=True, diag_sharey=False)
    g.map_lower(sns.kdeplot, color=sns.color_palette()[9], fill=False)
    g.map_upper(sns.kdeplot, color=sns.color_palette()[6], fill=False)
    g.map_diag(sns.kdeplot, linewidth=.5, fill=True, color=sns.color_palette()[3])

    # mark specific parameters (like truth for closure test, or MAP for experimental data analysis)
    if run_closure:
        truth_params = design.iloc[closure_val_pt].values

        # plot the truth parameters
        for i,n in enumerate(parameters_to_plot):
            ax=g.axes[i][i]
            ax.axvline(x=truth_params[n], ls='--', c=sns.color_palette()[5], label='Truth')

    # set axes labels
    label_list = list(param_dict.keys())
    for i, param in enumerate(parameters_to_plot):
        label = label_list[param] #label = label_list[int(ax.xaxis.get_label_text())]
        # label x-axes
        g.axes[len(parameters_to_plot)-1,i].xaxis.set_label_text(param_dict[label], fontsize = 14, visible=True)
        # label y-axes
        g.axes[i,0].yaxis.set_label_text(param_dict[label], fontsize = 14, visible=True)

    # add legend
    g = g.add_legend(loc='upper right', fontsize=36)
    plt.tight_layout()

    print("\nMaking corner plot of the posterior probability distributions of: \n")
    [print(label_list[i]) for i in parameters_to_plot]
    return g, spec_plotdir, chain_length, fraction_of_samples



@plot
def plot_posterior_parametrized_trio():

    # modify this path to store the posterior plot produced by this function in a given directory
    spec_plotdir = workdir / "posteriors" / "trio_plots" / ""
    spec_plotdir.mkdir(exist_ok=True)

    # includes plot title, [xlim pair], [ylim pair], [x and y axis labels pair], file name extension
    Plots = {
    0 : ["Rapidity" + " " + "loss" + " " + "posterior", [0,6], [0,5], ['$y_{init}$','$y_{loss}$'], 'yloss'],
    1 : ["Specific" + " " + "shear" + " " + "viscosity" + " " + "posterior", [.1,.4], [0,.5], ['T [GeV]','$\eta/s$'], 'shear'],
    2 : ["Specific" + " " + "bulk" + " " + "viscosity" + " " + "posterior", [.1,.4], [0,.2], ['T [GeV]','$\zeta/s$'], 'bulk']
    }

    # create lists to be returned to decorator wrapper
    list_of_figs = []
    list_of_names = []

    # initialize the grids
    Grid = [np.linspace(0, 6, 100), np.linspace(0.1, 0.4, 100) , np.linspace(0.1, 0.4, 100)]

    #--------------------------------------------------------------------------------------------------------#
    # Prior
    prior_all = [[],[],[]]
    # produce prior samples
    for row in np.random.uniform(design_min, design_max,(10000,20))[:,range(20)]:

        # select random prior parameters
        [ylossparam4at2, ylossparam4at4, ylossparam4at6] = [row[index] for index in [0,1,2]]
        [zmax, T0, width, asym] = [row[index] for index in [15,16,17,18]]
        [T_k, alow, ahigh, etas_k] = [row[index] for index in [11,12,13,14]]

        # evaluate the samples on the parametrized grids
        prior_y=[]; prior_shear=[]; prior_bulk=[]

        [prior_y.append(y_loss(point,ylossparam4at2, ylossparam4at4, ylossparam4at6)) for point in Grid[0]]
        [prior_shear.append(eta_over_s(point,T_k,alow,ahigh,etas_k)) for point in Grid[1]]
        [prior_bulk.append(zeta_over_s(point,zmax, T0, width, asym)) for point in Grid[2]]

        prior_all[0].append(prior_y); prior_all[1].append(prior_shear); prior_all[2].append(prior_bulk)
    #--------------------------------------------------------------------------------------------------------#


    #--------------------------------------------------------------------------------------------------------#
    # Posterior
    # sample posterior parameters
    chain_length = len(dataframe); fraction_of_samples = 0.02
    n_samples = int(fraction_of_samples*chain_length)
    sample = random.sample(range(0,chain_length), n_samples)

    post_all = [[],[],[]]
    for row in dataframe.iloc[sample,range(20)].values:
        # select random posterior parameters
        [ylossparam4at2, ylossparam4at4, ylossparam4at6] = [row[index] for index in [0,1,2]]
        [zmax, T0, width, asym] = [row[index] for index in [15,16,17,18]]
        [T_k, alow, ahigh, etas_k] = [row[index] for index in [11,12,13,14]]

        # evaluate the samples on the parametrized grids
        post_y=[]; post_shear=[]; post_bulk=[]

        [post_y.append(y_loss(point,ylossparam4at2, ylossparam4at4, ylossparam4at6)) for point in Grid[0]]
        [post_shear.append(eta_over_s(point,T_k,alow,ahigh,etas_k)) for point in Grid[1]]
        [post_bulk.append(zeta_over_s(point,zmax, T0, width, asym)) for point in Grid[2]]

        post_all[0].append(post_y); post_all[1].append(post_shear); post_all[2].append(post_bulk)
    #--------------------------------------------------------------------------------------------------------#

    # calculate the truth parameter values on the grids

    if run_closure:
        truth_params = design.iloc[closure_val_pt].values
        [ylossparam4at2, ylossparam4at4, ylossparam4at6] = [truth_params[index] for index in [0,1,2]]
        [zmax, T0, width, asym] = [truth_params[index] for index in [15,16,17,18]]
        [T_k, alow, ahigh, etas_k] = [truth_params[index] for index in [11,12,13,14]]

        yloss_truth = y_loss(Grid[0],ylossparam4at2, ylossparam4at4, ylossparam4at6)
        shear_truth = eta_over_s(Grid[1],T_k,alow,ahigh,etas_k)
        bulk_truth = zeta_over_s(Grid[2],zmax, T0, width, asym)
        truth = [yloss_truth, shear_truth, bulk_truth]


    # loop through the three parametrizations
    for i in range(3):
        # calculate the parameter values at given percentiles
        per0_pr,per5_pr,per20_pr,per50_pr,per80_pr,per95_pr,per100_pr=np.percentile(prior_all[i],[0,5,20,50,80,95,100], axis=0)
        per0,per5,per20,per50,per80,per95,per100=np.percentile(post_all[i],[0,5,20,50,80,95,100], axis=0)

        # create figure
        fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(8,6), sharex=False, sharey=False, constrained_layout=True)

        # plot the prior and posterior
        axes.fill_between(Grid[i], per5_pr,per95_pr,color=sns.color_palette()[7], alpha=0.6, label='90% Prior')

        axes.fill_between(Grid[i], per5, per95, color='crimson', label = "90% C.I. Posterior")
        #plt.plot(Grid[i],per5,'--g', linewidth=6, label = "90% C.I. Posterior")
        #plt.plot(Grid[i],per95,'--g',linewidth=6)

        if run_closure:
            axes.fill_between(Grid[i], per20, per80, color='limegreen', label = "60% C.I. Posterior")
            #plt.plot(Grid[i],per20,'-', color='limegreen', linewidth=4, label = "60% C.I. Posterior")
            #plt.plot(Grid[i],per80,'-', color='limegreen', linewidth=4)

            # calculate closure quantifier
            number_out_90 = 0
            number_out_60 = 0
            for pt in range(len(Grid[0])):
                if (truth[i][pt] < per5[pt]) or (truth[i][pt] > per95[pt]):
                    number_out_90 += 1
                if (truth[i][pt] < per20[pt]) or (truth[i][pt] > per80[pt]):
                    number_out_60 += 1

            #plt.text(.44, .26, "inside 90% band: " + str(np.round(1-number_out_90/len(Grid[0]),3)), ha='left', va='top', transform=axes.transAxes, fontsize = 17, family = "serif", bbox=dict(facecolor='white', alpha=0.8, edgecolor='none'))
            #plt.text(.44, .18, "inside 60% band: " + str(np.round(1-number_out_60/len(Grid[0]),3)), ha='left', va='top', transform=axes.transAxes, fontsize = 17, family = "serif", bbox=dict(facecolor='white', alpha=0.8, edgecolor='none'))


            # mark specific parameters (like truth for closure test, or MAP for experimental data analysis)
            plt.plot(Grid[i], truth[i], color = 'r', label = 'Truth', linewidth=5)

        plt.xlim(Plots[i][1][0],Plots[i][1][1]); plt.ylim(Plots[i][2][0],Plots[i][2][1])
        axes.legend(loc='upper right', fontsize=20)
        axes.tick_params(axis='both', which='major', labelsize=17)
        axes.set_xlabel(Plots[i][3][0], fontsize =22)
        axes.set_ylabel(Plots[i][3][1], fontsize =25)
        fig.suptitle(Plots[i][0], family = "serif", wrap=True, fontsize =20)

        list_of_figs.append(fig)
        list_of_names.append(Plots[i][4])

        print("\nPlotting:")
        print(Plots[i][0])
        print("with " + str(int(n_samples)) + " samples.\n")

    return list_of_figs, spec_plotdir, list_of_names, chain_length


@plot
def plot_posterior_observable_data():

    # modify this path to store the posterior plot produced by this function in a given directory
    spec_plotdir = workdir / "posteriors" / ""
    spec_plotdir.mkdir(exist_ok=True)

    # take representative sample of full posterior
    chain_length = len(dataframe)
    n_samples = 100
    sample = random.sample(range(0,chain_length), n_samples)
    print("Sampling " + str(int(n_samples)) +  " parameter sets of posterior chain of length " + str(chain_length))

    list_of_figs = []
    list_of_names = []


    for s in system_strs:
        fig = plt.figure(constrained_layout=True,figsize=(22, 20))
        plot_num = 1
        for obs in active_obs_list[s]:
            ax = fig.add_subplot(9,9,plot_num)
            x_bins = np.mean(obs_cent_list[s][obs],axis=1)

            # plot the experimental data
            obsdata = Y_exp_data[s][obs]["mean"]
            obsdata_err = (Y_exp_data[s][obs]["err"])
            plt.errorbar(x_bins, obsdata, yerr=obsdata_err, linestyle='', marker='s', mfc='k', mec='k', ms=3.5)


            # "plot" the calculations in white to maintain the observable prior axes limits
            for ipt, data in enumerate(trimmed_model_data[s][obs]):
                values = np.array(data["mean"])
                is_mult = ("dN" in obs) or ("dET" in obs)
                if is_mult and transform_multiplicities:
                    values = np.exp(values)
                ax.plot(x_bins, values, '-', color='white', alpha=0.05)

            # plot the posterior
            for posterior_sample in sample:
                # parameter set for posterior sample
                params = dataframe.iloc[posterior_sample]
                # run emulator for given parameter set
                mean = emu_dict[s].predict(np.array([params]), return_cov=False)
                # flatten mean aray
                values = mean[obs].flatten();
                # transform back if emulator trained on log-transformed observable
                is_mult = ("dN" in obs) or ("dET" in obs)
                if is_mult and transform_multiplicities:
                    values = np.exp(values)

                ax.plot(x_bins, values, '-r',alpha=0.05)

            ax.text(.95, .95, str(len(x_bins)) + ' bins', horizontalalignment='right', verticalalignment='top', transform=ax.transAxes)
            ax.text(.05, .05, str(obs), horizontalalignment='left', verticalalignment='bottom', transform=ax.transAxes, fontsize = 7)
            plot_num+=1

            ax.yaxis.set_ticks_position('both')
            ax.xaxis.set_ticks_position('both')
            ax.minorticks_on()
            ax.tick_params(axis="y",direction="in", pad=5)
            ax.tick_params(axis="x",direction="in", pad=5)

            is_mult = ("dN" in obs) or ("dET" in obs)
            if is_mult and transform_multiplicities:
                plt.yscale("log")

        plt.suptitle(s,fontsize = 16)
        #plt.show()

        list_of_figs.append(fig)
        list_of_names.append(s)
    return list_of_figs, spec_plotdir, list_of_names, chain_length

# Call plotting functions to be run
#plot_posterior_corner_20_params()
#plot_posterior_corner_rap_loss_bulk()
plot_posterior_parametrized_trio()
#plot_posterior_observable_data()
